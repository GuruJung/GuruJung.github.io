---
title: '[Numba 사용자 매뉴얼] 1.11 `@stencil` 데코레이터 사용하기'
strapline: "스텐실은 스텐실 커널이라고 불리는 어떤 고정된 패턴에 따라 배열 요소가 갱신이 되는, 공통의 계산 패턴이다."
header:
  overlay_image: /assets/images/index/python.jpg
categories:
  - "dev"
tag:
  - "numba"
  - "user_guide"
  - "translation"
  - "python"
classes: wide
toc: true
comments: true
mathjax: true
last_modified_at: 
---

스텐실은 스텐실 커널이라고 불리는 어떤 고정된 패턴에 따라 배열 요소가 갱신이 되는, 공통의 계산 패턴이다.
Numba는 `@stencil` 데코레이터를 제공하여 사용자가 쉽게 스텐실 커널을 지정하고 Numba가 어떤 입력 배열에 해당 커널을 적용하는
루프 코드를 생성토록 한다.
그러므로, 스텐실 데코레이터는 좀더 명백하고 좀더 간결한 코드를 유지하고, 
[parallel_jit_option]과 결합하여 스텐실 실행을 병렬화함으로써 성능을 좀 더 높인다.

## 기본 사용법

`@stencil` 데코레이터의 예제:

```python
    from numba import stencil

    @stencil
    def kernel1(a):
        return 0.25 * (a[0, 1] + a[1, 0] + a[0, -1] + a[-1, 0])
```

스텐실 커널은 표준 파이썬 함수 정의처럼 보이지만 배열 색인에 있어서 다른 의미를 가지고 있다.
스텐실은, 커널 정의에 따라 타입은 달라질 수 있다 하더라도, 입력 배열과 같은 크기와 모양을 가진 출력 배열을 생성한다.
개념적으로 스텐실 커널은 출력 배열의 각 요소에 대해서 한번씩만 실행된다. 
스텐실 커널로부터 리턴값은 출력 배열의 해당 요소에 쓰여진다.

파라미터 `a`는 커널이 적용될 때의 입력 배열을 뜻한다.
본 배열의 색인은 처리되고 있는 출력 배열의 현재 요소를 중심으로 처리된다.
예를 들어, 요소 `(x, y)`가 처리되고 있다면, 스텐실 커널에서 `a[0, 0]`은 입력 배열에서 `a[x + 0, y + 0]`에 해당한다.
유사하게 스텐실 커널의 `a[-1, 1]`은 입력 배열에서 `a[x - 1, y + 1]`에 해당한다.

커널에 따라 출력 배열의 경계에 대해 해당 커널을 적용 불가능할지도 모른다.
이는 입력 배열에 대해서 범위-밖 접근을 일으킬 수도 있기 때문이다.
스텐실 데코레이터가 이런 상황을 다루는 방법은 어떤 [stencil-mode]를 선택하는 지에 따라 달라진다.
기본 모드는 스텐실 데코레이터가 출력 배열의 경계선 요소들을 0으로 세팅하도록 하는 모드이다.

입력 배열상에 스텐실을 호출하려면 그것이 정규 함수인 것처럼 인수로 입력 배열을 건네면서 스텐실을 호출하는 것이다.
예를 들어 위에 정의된 커널을 사용하여:

```python
    >>> import numpy as np
    >>> input_arr = np.arange(100).reshape((10, 10))
    array([[ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9],
           [10, 11, 12, 13, 14, 15, 16, 17, 18, 19],
           [20, 21, 22, 23, 24, 25, 26, 27, 28, 29],
           [30, 31, 32, 33, 34, 35, 36, 37, 38, 39],
           [40, 41, 42, 43, 44, 45, 46, 47, 48, 49],
           [50, 51, 52, 53, 54, 55, 56, 57, 58, 59],
           [60, 61, 62, 63, 64, 65, 66, 67, 68, 69],
           [70, 71, 72, 73, 74, 75, 76, 77, 78, 79],
           [80, 81, 82, 83, 84, 85, 86, 87, 88, 89],
           [90, 91, 92, 93, 94, 95, 96, 97, 98, 99]])
    >>> output_arr = kernel1(input_arr)
    array([[  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.],
           [  0.,  11.,  12.,  13.,  14.,  15.,  16.,  17.,  18.,   0.],
           [  0.,  21.,  22.,  23.,  24.,  25.,  26.,  27.,  28.,   0.],
           [  0.,  31.,  32.,  33.,  34.,  35.,  36.,  37.,  38.,   0.],
           [  0.,  41.,  42.,  43.,  44.,  45.,  46.,  47.,  48.,   0.],
           [  0.,  51.,  52.,  53.,  54.,  55.,  56.,  57.,  58.,   0.],
           [  0.,  61.,  62.,  63.,  64.,  65.,  66.,  67.,  68.,   0.],
           [  0.,  71.,  72.,  73.,  74.,  75.,  76.,  77.,  78.,   0.],
           [  0.,  81.,  82.,  83.,  84.,  85.,  86.,  87.,  88.,   0.],
           [  0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.,   0.]])
    >>> input_arr.dtype
    dtype('int64')
    >>> output_arr.dtype
    dtype('float64')
```

스텐실 데코레이터는 주어진 스텐실 커널의 출력 타입이 `float64`라고 판단했음에 유의한다.
그래서 입력 배열의 타입이 `int64`인데 반해 `float64` 타입의 출력 배열을 생성하였다.

## 스텐실 파라미터

스텐실 커널 정의시 여러 개의 인수를 취할 수 있는 데 다음과 같은 조건을 따라야 한다.
첫번째 인수는 반드시 배열이어야 한다.
출력 배열의 크기와 모양(shape)은 첫번째 인수의 것과 같을 것이다.
부가적인 인수들은 스칼라나 배열 둘 다 가능하다.
배열 인수에 대해서는 최소한 각 차원에서 첫번째 인수(배열)보다 같거나 커야 한다.
배열 색인은 모두 입력 배열에 상대적이다.

### 커널 모양 추론 및 경계선 핸들링 {#stencil-kernel-shape-inference}

위의 예제 및 대부분의 경우에 스텐실 커널에서의 배열 색인은 `정수` 숫자만 사용가능하다.
그런 경우 스텐실 데코레이터는 스텐실 커널을 분석하여 커널의 크기를 판단할 수 있다.
위의 예에서 스텐실 데코레이터는 커널이 `3 x 3` 모양이라고 판단하는데, 첫번째 및 두번째 차원 모두에서
`-1`부터 `1`까지의 색인이 사용되었기 때문이다.
스텐실 데코레이터는 또한 비대칭 또는 정사각이 아닌 형태의 스텐실 커널도 올바르게 다룰 수 있음에 유의한다.

스텐실 커널의 크기에 기반하여 스텐실 데코레이터는 출력 배열에서 경계선의 크기를 계산할 수 있다.
입력 배열의 어떤 요소에 대해서 커널을 적용할 때 범위를 벗어난 색인이 생긴다면,
해당 요소는 출력 배열의 경계에 속한다.
위의 예제에서는 `-1`과 `+1`에서 접근되는 점들이기 때문에 출력 배열은 모든 차원에서 크기가 1인 경계를 가지고 있다.

병렬 모드는 표현식이 간단하다면 커널 색인을 추론할 수 있다.
예를 들어:

```python
    @njit(parallel=True)
    def stencil_test(A):
        c = 2
        B = stencil(
            lambda a, c: 0.3 * (a[-c+1] + a[0] + a[c-1]))(A, c)
        return B
```

## 스텐실 데코레이터 옵션 

**Note:** 
스텐실 데코레이터에 경계선 핸들링에 관한 추가적인 메커니즘을 미래에는 제공할 것이다.
현재는 오직 하나의 방법이 구현되어 있는데, 바로 `"constant"`이다
(자세한 것은 아래의 `func_or_mode`를 참고한다).
{: .notice--warning}

### `neighborhood` {#stencil-neighborhood}

때때로 `정수` 숫자로만 스텐실 커널을 작성하는 게 불편할 수도 있다. 
예를 들면, 시계열 데이터의 30일 이동 평균을 계산하고 싶다고 하자.
어떤 이는 `(a[-29] + a[-28] + ... + a[-1] + a[0]) / 30`를 작성할 수도 있지만,
스텐실 데코레이터는 `neighborhood` 옵션을 사용하여 좀더 간결한 형태를 지원한다:

```python
    @stencil(neighborhood = ((-29, 0),))
    def kernel2(a):
        cumul = 0
        for i in range(-29, 1):
            cumul += a[i]
        return cumul / 30
```

이웃(neighborhood) 옵션은 튜플의 튜플이다.
외부 튜플의 길이는 입력 배열의 차원 개수와 동일하다.
내부 튜플의 길이는 항상 2이고, 해당 차원에서 사용되는 최소와 최대 인덱스 차이를 가지고 있다.

사용자가 이웃을 지정하였으나 커널이 지정된 이웃 범위를 벗어나는 요소를 접근한다면
**그 결과는 정의되어 있지 않다.**

### `func_or_mode` {#stencil-mode}

`func_or_mode`라는 선택적 파라미터는 출력 배열의 경계가 어떻게 핸들링되어야 할지를 지정한다.
현재는 오직 하나의 값만 지원하는 데 바로 `"constant"`이다.
`constant` 모드에서는 입력 배열의 바깥을 접근하게 되는 경우에는 스텐실 커널이 적용되지 않는다.
그런 경우 입력 배열의 해당 요소들 (경계에 있는)은 `cval` 파라미터에 의해 지정된 상수 값을 할당받는다.

### `cval`

cval 파라미터는 기본적으로 0인데, 사용자에 의해 주어진 값으로 세팅될 수 있다.
`func_or_mode` 파라미터가 `constant`로 세팅되어 있다면 출력 배열의 경계선 값으로 사용된다.
다른 모드에서는 cval 파라미터가 무시된다.
cval 파라미터의 타입은 스텐실 커널의 리턴값과 매치되어야 한다.
사용자가 출력 배열의 타입을 특정 타입으로 하고자 한다면 스텐실 커널이 해당 타입을 리턴하도록 보장해야 한다.

### `standard_indexing`

기본적으로 스텐실 커널에서의 모든 배열 접근은 위에서 언급된대로 상대적 색인으로 처리된다.
그러나 가끔씩 스텐실 커널에 전달되는 보조 배열(e.g. 가중치 배열)이 상대 색인이 아닌 표준 파이썬 색인을 사용하는 것이 편리한 경우가 있다.
이런 목적으로 스텐실 데코레이터는 `standard_indexing` 옵션이 가지고 있는데,
옵션의 값은 상대 색인이 아닌 표준 파이썬 색인으로 접근되어야 하는 배열들의 이름 모음이다:

```python
    @stencil(standard_indexing=("b",))
    def kernel3(a, b):
        return a[-1] * b[0] + a[0] + b[1]
```

## `StencilFunc`

스텐실 데코레이터는 `StencilFunc`이라는 타입의 호출 가능한 개체를 반환한다.
`StencilFunc` 개체는 많은 수의 속성을 포함하고 있지만
사용자가 관심을 가질만한 것은 유일하게 `neighborhood` 속성이다.
`neighborhood` 옵션이 스텐실 데코레이터에 전달되었다면
제공된 값이 이 속성에 저장된다.
그렇지 않다면, 첫 실행이나 컴파일때 시스템이 이 값을 위에서 언급한 방식으로 계산하여 이 속성에 집어 넣는다.
사용자는 계산된 neighborhood 값이 맞는지를 이 속성을 조사함으로써 검증할 수 있다.

## 스텐실 호출 옵션

내부적으로 스텐실 데코레이터는 주어진 스텐실 커널을 정규 파이썬 함수로 변환한다.
이 함수는 스텐실 커널 정의 때 지정된 것과 같은 파라미터를 가지나 아래와 같은 선택적 파라미터 또한 포함하게 된다.

### `out` {#stencil-function-out}

`out` 선택적 파라미터는 Numba가 생성한 모든 스텐실 함수에 더해진다.
`out` 파라미터에 사용자가 미리 할당한 배열을 지정한다면, Numba는 스텐실의 출력에 사용될 출력 배열으로 그것을 사용할 것이다.
이 경우 스텐실 함수는 출력 배열을 직접 할당하지 않을 것이다.
[Numpy ufunc casting rules]에 따라 스텐실 커널의 리턴 타입이, 사용자가 지정한 출력 배열의 요소 타입으로 안전하게 캐스팅된다고 사용자가 보증해야 한다. 

아래에 예시 사용법이 있다:

```python
    >>> import numpy as np
    >>> input_arr = np.arange(100).reshape((10, 10))
    >>> output_arr = np.full(input_arr.shape, 0.0)
    >>> kernel1(input_arr, out=output_arr)
```


[parallel_jit_option]: /dev/numba_user_jit#parallel-jit-option "병렬"
[stencil-mode]: #stencil-mode "스텐실 모드"
[Numpy ufunc casting rules]: http://docs.scipy.org/doc/numpy/reference/ufuncs.html#casting-rules "Numpy ufunc 캐스팅 규칙"


**Note:** 
이 글은 Numba user manual을 번역한 글입니다.
[목차](/dev/numba_user_index)를 보려면 [여기](/dev/numba_user_index)를 클릭하세요.
{: .notice--warning}
